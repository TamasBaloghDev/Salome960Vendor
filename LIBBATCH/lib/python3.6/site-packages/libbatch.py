# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_libbatch')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_libbatch')
    _libbatch = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libbatch', [dirname(__file__)])
        except ImportError:
            import _libbatch
            return _libbatch
        try:
            _mod = imp.load_module('_libbatch', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _libbatch = swig_import_helper()
    del swig_import_helper
else:
    import _libbatch
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class Job(_object):
    """Proxy of C++ Batch::Job class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Job, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Job, name)

    def __init__(self, *args):
        """
        __init__(Batch::Job self) -> Job
        __init__(Batch::Job self, Batch::Parametre param) -> Job
        __init__(Batch::Job self, Batch::Environnement env) -> Job
        __init__(Batch::Job self, Batch::Parametre param, Batch::Environnement env) -> Job
        """
        this = _libbatch.new_Job(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _libbatch.delete_Job
    __del__ = lambda self: None

    def getParametre(self) -> "Batch::Parametre":
        """getParametre(Job self) -> Batch::Parametre"""
        return _libbatch.Job_getParametre(self)


    def setParametre(self, arg2: 'Batch::Parametre const &') -> "void":
        """setParametre(Job self, Batch::Parametre const & arg2)"""
        return _libbatch.Job_setParametre(self, arg2)


    def getEnvironnement(self) -> "Batch::Environnement":
        """getEnvironnement(Job self) -> Batch::Environnement"""
        return _libbatch.Job_getEnvironnement(self)


    def setEnvironnement(self, arg2: 'Batch::Environnement const &') -> "void":
        """setEnvironnement(Job self, Batch::Environnement const & arg2)"""
        return _libbatch.Job_setEnvironnement(self, arg2)


    def __str__(self) -> "std::string":
        """__str__(Job self) -> std::string"""
        return _libbatch.Job___str__(self)


    def __repr__(self) -> "std::string":
        """__repr__(Job self) -> std::string"""
        return _libbatch.Job___repr__(self)

Job_swigregister = _libbatch.Job_swigregister
Job_swigregister(Job)

class JobId(_object):
    """Proxy of C++ Batch::JobId class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JobId, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JobId, name)
    __swig_destroy__ = _libbatch.delete_JobId
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(Batch::JobId self) -> JobId
        __init__(Batch::JobId self, BatchManager arg2, std::string const & ref) -> JobId
        __init__(Batch::JobId self, JobId arg2) -> JobId
        """
        this = _libbatch.new_JobId(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getReference(self) -> "std::string":
        """getReference(JobId self) -> std::string"""
        return _libbatch.JobId_getReference(self)


    def setReference(self, new_reference: 'std::string const &') -> "void":
        """setReference(JobId self, std::string const & new_reference)"""
        return _libbatch.JobId_setReference(self, new_reference)


    def deleteJob(self) -> "void":
        """deleteJob(JobId self)"""
        return _libbatch.JobId_deleteJob(self)


    def holdJob(self) -> "void":
        """holdJob(JobId self)"""
        return _libbatch.JobId_holdJob(self)


    def releaseJob(self) -> "void":
        """releaseJob(JobId self)"""
        return _libbatch.JobId_releaseJob(self)


    def alterJob(self, *args) -> "void":
        """
        alterJob(JobId self, Batch::Parametre const & param, Batch::Environnement const & env)
        alterJob(JobId self, Batch::Parametre const & param)
        alterJob(JobId self, Batch::Environnement const & env)
        """
        return _libbatch.JobId_alterJob(self, *args)


    def setParametre(self, param: 'Batch::Parametre const &') -> "void":
        """setParametre(JobId self, Batch::Parametre const & param)"""
        return _libbatch.JobId_setParametre(self, param)


    def setEnvironnement(self, env: 'Batch::Environnement const &') -> "void":
        """setEnvironnement(JobId self, Batch::Environnement const & env)"""
        return _libbatch.JobId_setEnvironnement(self, env)


    def queryJob(self) -> "Batch::JobInfo":
        """queryJob(JobId self) -> JobInfo"""
        return _libbatch.JobId_queryJob(self)


    def __str__(self) -> "std::string":
        """__str__(JobId self) -> std::string"""
        return _libbatch.JobId___str__(self)


    def __repr__(self) -> "std::string":
        """__repr__(JobId self) -> std::string"""
        return _libbatch.JobId___repr__(self)

JobId_swigregister = _libbatch.JobId_swigregister
JobId_swigregister(JobId)

class JobInfo(_object):
    """Proxy of C++ Batch::JobInfo class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JobInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JobInfo, name)
    __swig_destroy__ = _libbatch.delete_JobInfo
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(Batch::JobInfo self) -> JobInfo
        __init__(Batch::JobInfo self, JobInfo jinfo) -> JobInfo
        """
        this = _libbatch.new_JobInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getParametre(self) -> "Batch::Parametre":
        """getParametre(JobInfo self) -> Batch::Parametre"""
        return _libbatch.JobInfo_getParametre(self)


    def getEnvironnement(self) -> "Batch::Environnement":
        """getEnvironnement(JobInfo self) -> Batch::Environnement"""
        return _libbatch.JobInfo_getEnvironnement(self)


    def Tokenize(*args) -> "void":
        """
        Tokenize(std::string const & str, std::vector< std::string > & tokens, std::string const & delimiters)
        Tokenize(std::string const & str, std::vector< std::string > & tokens)
        """
        return _libbatch.JobInfo_Tokenize(*args)

    Tokenize = staticmethod(Tokenize)

    def __str__(self) -> "std::string":
        """__str__(JobInfo self) -> std::string"""
        return _libbatch.JobInfo___str__(self)


    def __repr__(self) -> "std::string":
        """__repr__(JobInfo self) -> std::string"""
        return _libbatch.JobInfo___repr__(self)

JobInfo_swigregister = _libbatch.JobInfo_swigregister
JobInfo_swigregister(JobInfo)

def JobInfo_Tokenize(*args) -> "void":
    """
    Tokenize(std::string const & str, std::vector< std::string > & tokens, std::string const & delimiters)
    JobInfo_Tokenize(std::string const & str, std::vector< std::string > & tokens)
    """
    return _libbatch.JobInfo_Tokenize(*args)

SH = _libbatch.SH
SSH = _libbatch.SSH
RSH = _libbatch.RSH
RSYNC = _libbatch.RSYNC
class CommunicationProtocol(_object):
    """Proxy of C++ Batch::CommunicationProtocol class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommunicationProtocol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CommunicationProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libbatch.delete_CommunicationProtocol
    __del__ = lambda self: None

    def getInstance(protocolType: 'Batch::CommunicationProtocolType') -> "Batch::CommunicationProtocol const &":
        """getInstance(Batch::CommunicationProtocolType protocolType) -> CommunicationProtocol"""
        return _libbatch.CommunicationProtocol_getInstance(protocolType)

    getInstance = staticmethod(getInstance)

    def getExecCommand(self, subCommand: 'std::string const &', host: 'std::string const &', user: 'std::string const &') -> "std::string":
        """getExecCommand(CommunicationProtocol self, std::string const & subCommand, std::string const & host, std::string const & user) -> std::string"""
        return _libbatch.CommunicationProtocol_getExecCommand(self, subCommand, host, user)


    def getExecCommandArgs(self, subCommand: 'std::string const &', host: 'std::string const &', user: 'std::string const &') -> "std::vector< std::string >":
        """getExecCommandArgs(CommunicationProtocol self, std::string const & subCommand, std::string const & host, std::string const & user) -> std::vector< std::string >"""
        return _libbatch.CommunicationProtocol_getExecCommandArgs(self, subCommand, host, user)


    def copyFile(self, sourcePath: 'std::string const &', sourceHost: 'std::string const &', sourceUser: 'std::string const &', destinationPath: 'std::string const &', destinationHost: 'std::string const &', destinationUser: 'std::string const &') -> "int":
        """copyFile(CommunicationProtocol self, std::string const & sourcePath, std::string const & sourceHost, std::string const & sourceUser, std::string const & destinationPath, std::string const & destinationHost, std::string const & destinationUser) -> int"""
        return _libbatch.CommunicationProtocol_copyFile(self, sourcePath, sourceHost, sourceUser, destinationPath, destinationHost, destinationUser)


    def removeFile(self, path: 'std::string const &', host: 'std::string const &', user: 'std::string const &') -> "int":
        """removeFile(CommunicationProtocol self, std::string const & path, std::string const & host, std::string const & user) -> int"""
        return _libbatch.CommunicationProtocol_removeFile(self, path, host, user)


    def removeDirectory(self, path: 'std::string const &', host: 'std::string const &', user: 'std::string const &') -> "int":
        """removeDirectory(CommunicationProtocol self, std::string const & path, std::string const & host, std::string const & user) -> int"""
        return _libbatch.CommunicationProtocol_removeDirectory(self, path, host, user)


    def makeDirectory(self, path: 'std::string const &', host: 'std::string const &', user: 'std::string const &') -> "int":
        """makeDirectory(CommunicationProtocol self, std::string const & path, std::string const & host, std::string const & user) -> int"""
        return _libbatch.CommunicationProtocol_makeDirectory(self, path, host, user)


    def getType(self) -> "Batch::CommunicationProtocolType":
        """getType(CommunicationProtocol self) -> Batch::CommunicationProtocolType"""
        return _libbatch.CommunicationProtocol_getType(self)

CommunicationProtocol_swigregister = _libbatch.CommunicationProtocol_swigregister
CommunicationProtocol_swigregister(CommunicationProtocol)

def CommunicationProtocol_getInstance(protocolType: 'Batch::CommunicationProtocolType') -> "Batch::CommunicationProtocol const &":
    """CommunicationProtocol_getInstance(Batch::CommunicationProtocolType protocolType) -> CommunicationProtocol"""
    return _libbatch.CommunicationProtocol_getInstance(protocolType)

class BatchManager(_object):
    """Proxy of C++ Batch::BatchManager class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BatchManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BatchManager, name)

    def __init__(self, *args):
        """
        __init__(Batch::BatchManager self, FactBatchManager parent, char const * host, char const * username, Batch::CommunicationProtocolType protocolType, char const * mpiImpl) -> BatchManager
        __init__(Batch::BatchManager self, FactBatchManager parent, char const * host, char const * username, Batch::CommunicationProtocolType protocolType) -> BatchManager
        __init__(Batch::BatchManager self, FactBatchManager parent, char const * host, char const * username) -> BatchManager
        __init__(Batch::BatchManager self, FactBatchManager parent, char const * host) -> BatchManager
        __init__(Batch::BatchManager self, FactBatchManager parent) -> BatchManager
        """
        this = _libbatch.new_BatchManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _libbatch.delete_BatchManager
    __del__ = lambda self: None

    def __repr__(self) -> "std::string":
        """__repr__(BatchManager self) -> std::string"""
        return _libbatch.BatchManager___repr__(self)


    def getJobIdByReference(self, ref: 'char const *') -> "Batch::JobId const":
        """getJobIdByReference(BatchManager self, char const * ref) -> JobId"""
        return _libbatch.BatchManager_getJobIdByReference(self, ref)


    def submitJob(self, job: 'Job') -> "Batch::JobId const":
        """submitJob(BatchManager self, Job job) -> JobId"""
        return _libbatch.BatchManager_submitJob(self, job)


    def deleteJob(self, jobid: 'JobId') -> "void":
        """deleteJob(BatchManager self, JobId jobid)"""
        return _libbatch.BatchManager_deleteJob(self, jobid)


    def holdJob(self, jobid: 'JobId') -> "void":
        """holdJob(BatchManager self, JobId jobid)"""
        return _libbatch.BatchManager_holdJob(self, jobid)


    def releaseJob(self, jobid: 'JobId') -> "void":
        """releaseJob(BatchManager self, JobId jobid)"""
        return _libbatch.BatchManager_releaseJob(self, jobid)


    def alterJob(self, *args) -> "void":
        """
        alterJob(BatchManager self, JobId jobid, Batch::Parametre const & param, Batch::Environnement const & env)
        alterJob(BatchManager self, JobId jobid, Batch::Parametre const & param)
        alterJob(BatchManager self, JobId jobid, Batch::Environnement const & env)
        """
        return _libbatch.BatchManager_alterJob(self, *args)


    def queryJob(self, jobid: 'JobId') -> "Batch::JobInfo":
        """queryJob(BatchManager self, JobId jobid) -> JobInfo"""
        return _libbatch.BatchManager_queryJob(self, jobid)


    def addJob(self, job: 'Job', reference: 'std::string const &') -> "Batch::JobId const":
        """addJob(BatchManager self, Job job, std::string const & reference) -> JobId"""
        return _libbatch.BatchManager_addJob(self, job, reference)


    def waitForJobEnd(self, jobid: 'JobId', timeout: 'long'=-1, initSleepTime: 'long'=1, maxSleepTime: 'long'=600) -> "std::string":
        """
        waitForJobEnd(BatchManager self, JobId jobid, long timeout=-1, long initSleepTime=1, long maxSleepTime=600) -> std::string
        waitForJobEnd(BatchManager self, JobId jobid, long timeout=-1, long initSleepTime=1) -> std::string
        waitForJobEnd(BatchManager self, JobId jobid, long timeout=-1) -> std::string
        waitForJobEnd(BatchManager self, JobId jobid) -> std::string
        """
        return _libbatch.BatchManager_waitForJobEnd(self, jobid, timeout, initSleepTime, maxSleepTime)


    def importOutputFiles(self, job: 'Job', directory: 'std::string const') -> "void":
        """importOutputFiles(BatchManager self, Job job, std::string const directory)"""
        return _libbatch.BatchManager_importOutputFiles(self, job, directory)


    def importDumpStateFile(self, job: 'Job', directory: 'std::string const') -> "bool":
        """importDumpStateFile(BatchManager self, Job job, std::string const directory) -> bool"""
        return _libbatch.BatchManager_importDumpStateFile(self, job, directory)


    def importWorkFile(self, job: 'Job', work_file: 'std::string const &', directory: 'std::string const &') -> "bool":
        """importWorkFile(BatchManager self, Job job, std::string const & work_file, std::string const & directory) -> bool"""
        return _libbatch.BatchManager_importWorkFile(self, job, work_file, directory)


    def clearWorkingDir(self, job: 'Job') -> "void":
        """clearWorkingDir(BatchManager self, Job job)"""
        return _libbatch.BatchManager_clearWorkingDir(self, job)


    def getProtocol(self) -> "Batch::CommunicationProtocol const &":
        """getProtocol(BatchManager self) -> CommunicationProtocol"""
        return _libbatch.BatchManager_getProtocol(self)


    def exportInputFiles(self, job: 'Job') -> "void":
        """exportInputFiles(BatchManager self, Job job)"""
        return _libbatch.BatchManager_exportInputFiles(self, job)

BatchManager_swigregister = _libbatch.BatchManager_swigregister
BatchManager_swigregister(BatchManager)

class BatchManagerCatalog(_object):
    """Proxy of C++ Batch::BatchManagerCatalog class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BatchManagerCatalog, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BatchManagerCatalog, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getInstance() -> "Batch::BatchManagerCatalog &":
        """getInstance() -> BatchManagerCatalog"""
        return _libbatch.BatchManagerCatalog_getInstance()

    getInstance = staticmethod(getInstance)

    def addFactBatchManager(self, type: 'char const *', pFBM: 'FactBatchManager') -> "void":
        """addFactBatchManager(BatchManagerCatalog self, char const * type, FactBatchManager pFBM)"""
        return _libbatch.BatchManagerCatalog_addFactBatchManager(self, type, pFBM)


    def hasFactBatchManager(self, type: 'char const *') -> "bool":
        """hasFactBatchManager(BatchManagerCatalog self, char const * type) -> bool"""
        return _libbatch.BatchManagerCatalog_hasFactBatchManager(self, type)


    def __call__(self, type: 'char const *') -> "Batch::FactBatchManager *":
        """__call__(BatchManagerCatalog self, char const * type) -> FactBatchManager"""
        return _libbatch.BatchManagerCatalog___call__(self, type)


    def dict(self) -> "std::map< std::string,Batch::FactBatchManager * > *":
        """dict(BatchManagerCatalog self) -> std::map< std::string,Batch::FactBatchManager * > *"""
        return _libbatch.BatchManagerCatalog_dict(self)


    def __repr__(self) -> "std::string":
        """__repr__(BatchManagerCatalog self) -> std::string"""
        return _libbatch.BatchManagerCatalog___repr__(self)

BatchManagerCatalog_swigregister = _libbatch.BatchManagerCatalog_swigregister
BatchManagerCatalog_swigregister(BatchManagerCatalog)

def BatchManagerCatalog_getInstance() -> "Batch::BatchManagerCatalog &":
    """BatchManagerCatalog_getInstance() -> BatchManagerCatalog"""
    return _libbatch.BatchManagerCatalog_getInstance()

class FactBatchManager(_object):
    """Proxy of C++ Batch::FactBatchManager class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactBatchManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FactBatchManager, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _libbatch.delete_FactBatchManager
    __del__ = lambda self: None

    def __call__(self, *args) -> "Batch::BatchManager *":
        """
        __call__(FactBatchManager self, char const * hostname, char const * username, Batch::CommunicationProtocolType protocolType, char const * mpi) -> BatchManager
        __call__(FactBatchManager self, char const * hostname, char const * username, Batch::CommunicationProtocolType protocolType) -> BatchManager
        __call__(FactBatchManager self, char const * hostname, char const * username) -> BatchManager
        __call__(FactBatchManager self, char const * hostname) -> BatchManager
        """
        return _libbatch.FactBatchManager___call__(self, *args)


    def getType(self) -> "std::string const &":
        """getType(FactBatchManager self) -> std::string const &"""
        return _libbatch.FactBatchManager_getType(self)


    def __repr__(self) -> "std::string":
        """__repr__(FactBatchManager self) -> std::string"""
        return _libbatch.FactBatchManager___repr__(self)

FactBatchManager_swigregister = _libbatch.FactBatchManager_swigregister
FactBatchManager_swigregister(FactBatchManager)

# This file is compatible with both classic and new-style classes.

cvar = _libbatch.cvar
ARGUMENTS = cvar.ARGUMENTS
ASSIGNEDHOSTNAMES = cvar.ASSIGNEDHOSTNAMES
EXECUTABLE = cvar.EXECUTABLE
ID = cvar.ID
INFILE = cvar.INFILE
MAXCPUTIME = cvar.MAXCPUTIME
MAXDISKSIZE = cvar.MAXDISKSIZE
MAXRAMSIZE = cvar.MAXRAMSIZE
MAXWALLTIME = cvar.MAXWALLTIME
NAME = cvar.NAME
NBPROC = cvar.NBPROC
NBPROCPERNODE = cvar.NBPROCPERNODE
OUTFILE = cvar.OUTFILE
QUEUE = cvar.QUEUE
STATE = cvar.STATE
WORKDIR = cvar.WORKDIR
EXCLUSIVE = cvar.EXCLUSIVE
MEMPERCPU = cvar.MEMPERCPU
WCKEY = cvar.WCKEY
EXTRAPARAMS = cvar.EXTRAPARAMS
PREPROCESS = cvar.PREPROCESS
PARTITION = cvar.PARTITION
NBNODE = cvar.NBNODE
LAUNCHER_FILE = cvar.LAUNCHER_FILE
LAUNCHER_ARGS = cvar.LAUNCHER_ARGS
CREATED = cvar.CREATED
IN_PROCESS = cvar.IN_PROCESS
QUEUED = cvar.QUEUED
RUNNING = cvar.RUNNING
PAUSED = cvar.PAUSED
FINISHED = cvar.FINISHED
FAILED = cvar.FAILED

